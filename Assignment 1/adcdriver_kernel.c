#include<linux/init.h>
#include<linux/module.h>
#include<linux/version.h>
#include<linux/kernel.h>
#include<linux/types.h>
#include<linux/fs.h>
#include<linux/kdev_t.h>
#include<linux/cdev.h>
#include<linux/random.h>
#include <linux/uaccess.h>
#include "adcchardev1.h"

#define PASS 0
#define FAIL 1

static dev_t adc;
static struct cdev c_dev;
static struct class *class;
static uint16_t ch = 0;
static uint16_t conv;
static char all_set = 'r';
static int Device_Open = 0;

uint16_t randomgenerator(void);


static int adc_open(struct inode *i,struct file *f)
{
		if (Device_Open)
        		return -FAIL;

    		Device_Open++;
		return PASS;
	}


static int adc_close(struct inode *i,struct file *f){
		Device_Open--;
		return PASS;

	}


static ssize_t adc_read(struct file *f, char __user *buf, size_t len, loff_t *off)

{
    	int setbits;
    	uint16_t randno;
    	randno = randomgenerator();
	printk(KERN_INFO " random number generated by driver is %d",randno);
	if(all_set == 'l')
	{									
	// for left all_setignment		
	randno = randno * 16;
	// one bit left shift is equal_set to *2 so 4 bit leftshift is *16				
        }   
	printk(KERN_INFO "Current channel being used is %d and data all_setignment %c ",ch,all_set);
    	setbits = copy_to_user(buf,&randno,sizeof(randno));
    	if(setbits!=0){
    printk(KERN_INFO "Failed to copy %d byte(s) to the userspace ",setbits);
    }
		return sizeof(randno);

	}


long adc_ioctl(struct file *file,unsigned int ioctl_num,unsigned long ioctl_param){

                switch(ioctl_num)
{
                  case SEL_CHANNEL:
			     ch = ioctl_param;
			//printk(KERN_INFO "current request code from channel is %u",ioctl_num);
                    	printk(KERN_INFO "CHANNEL SELECTED IS %d",ch);
			break;

                  case SEL_ALIGNMENT:
                    	all_set = (char)ioctl_param;
			//printk(KERN_INFO "current request code from all_setignment is %u",ioctl_num);
                    	printk(KERN_INFO "ALIGNMENT SELECTED - %c",all_set);
			break;

                  case SEL_CONV:
                    	conv = ioctl_param;

			//printk(KERN_INFO "current request code for conversion is %u",ioctl_num);
                    	printk(KERN_INFO "CONV SELECTED - %d",conv);
			break;
                }
              return PASS;
  }
// use of the random generator functions 

uint16_t randomgenerator(void)
{
    unsigned int num;
    get_random_bytes(&num, 2);
    num%=4095;
    return (uint16_t)num;
  }


// file operation structure - file pointer is created in the dev directory
static struct file_operations fops =
					{
					.owner = THIS_MODULE,
					.open = adc_open,
					.release = adc_close,
                                       .unlocked_ioctl = adc_ioctl,
					.read = adc_read
					};

__init int adcdriver_init(void)
{
	//  all_setlocation of major and minor numbers.
	if(alloc_chrdev_region(&adc,0,5,"VIVEK")<0)
    
    {
		return -1;
	}
	printk(KERN_INFO "<major , minor>:<%d,%d>\n",MAJOR(adc),MINOR(adc));// to see the all_setloted major and minor no.

	// Creation of device file.
	if((class=class_create(THIS_MODULE,"adcclass"))==NULL)
    
    {
		printk(KERN_INFO "Failed to create class exiting");
			unregister_chrdev_region(adc,1);
			return -1;
	
    }
	
    if((device_create(class,NULL,adc,NULL,"adc-dev"))==NULL)
    
    {
		printk(KERN_INFO "Failed to create device file in the dev directory");
			class_destroy(class);
			unregister_chrdev_region(adc,1);
			return -1;
	}
	// Link fops and cdev to device node;
	cdev_init(&c_dev,&fops);
	
    
    //making the driver live
	if(cdev_add(&c_dev,adc, 1)==-1)
    {
		device_destroy(class,adc);
		class_destroy(class);
		unregister_chrdev_region(adc,1);

		printk(KERN_INFO "Failed to make driver live exiting");
		return -1;
	}

	printk(KERN_INFO "kernel module Inserted!!!!! Congratulations!!!!!");
	return PASS;
}


__exit void adcdriver_exit(void){
	cdev_del(&c_dev);
	device_destroy(class,adc);
	class_destroy(class);
	printk(KERN_INFO "returned from the Linux kernel module");
	unregister_chrdev_region(adc,3);
	printk(KERN_INFO "Deleted Successfully");
}


module_init(adcdriver_init);
module_exit(adcdriver_exit);
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("12 bit 8 channel adc");
MODULE_AUTHOR("VIVEK KUMAR <h20210163@pilani.bits-pilani.ac.in>");

